---
title: "Homework 05"
author: "Biology Student"
date: "2/25/2020"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Loading Libraries
Use the following syntax to load any libraries that you need. This code will prevent errors that will interfere with knitting of the Rmd file.
Also note that the `include=FALSE` option will prevent this code chunk from appearing in the markdown file.

We will load the entire tidyverse library, which includes *dplyr*, *ggplot2*, *readr*, and other packages.

```{r Load Libraries, include=FALSE}
if (!require("tidyverse")) install.packages("tidyverse"); library(tidyverse)
if (!require("UsingR")) install.packages("UsingR"); library(UsingR)
if (!require("cowplot")) install.packages("cowplot"); library(cowplot)

```



Main Database With Generation and Legendary flag.

Accessed from https://www.kaggle.com/abcsds/pokemon




## Data import and checking

The datafile itself is in csv format and is of a decent size.
```{r Import data}
project_data <- read.csv("Pokemon.csv")

```

Check the data, make sure everything has been imported. 
```{r Check data}
str(project_data)
cat("rows", nrow(project_data))
cat("\ncolumns", ncol(project_data))

head(project_data)
tail(project_data)
project_data
```
Checking out the dataset we can see that we have a number of variables which describe some basic information about each 
Pokemon, notably their battle stats and Legendary status. According to the Pokemon company there are currently 807 Pokemon.
Since this dataset only includes 721 Pokemon up to generation 6, it's likely that the dataset is missing Pokedex entries from
the most recent games. This is okay because I stopped playing Pokemon after generation 4 so I could care less about these
new-fangled pokemons. We don't immediately see any NA's however that doesn't mean they aren't present. We'll check that next.

To check if we have NA's in the dataset that aren't found by head/tail sampling we can use the following code to count NA 
instances.
```{r Count NA}
sum(is.na(project_data)) 
```
Since the number of NA's is 0 we will not need to take care and account for them later when making graphs.

## Data wrangling

At this stage we can proceed to cut down the dataset to suit our purposes. Since I have no a mild attatchment to the pokemon
I used when I was a kid we'll filter out the later generations of pokemon.
```{r Filter out developing countries}

pokemon <- dplyr::filter(project_data, Generation <= 4)


#developed <- dplyr::filter(project_data, Status == "Developed")
#developed <- dplyr::filter(developed, Hepatitis.B > 11)
#developed <- dplyr::select(developed, -GDP, -Population, -percentage.expenditure, -BMI)
#developed

pokemon
```

I recently found out that competitive pokemon battling is kind of a thing which is pretty cool and brings me back to when I was
obsessed with pokemon in middle-school. Having found a dataset with pokemon

```{r}
simple.eda(pokemon$Attack)
simple.eda(pokemon$Sp..Atk)
simple.eda(pokemon$Speed)

```

When I was a kid I really wanted to be a gym leader... A pokemon gym leader. Many pokemon gym leaders will follow a theme when
it comes to picking their team members. 

In pokemon battles, being able to make the first move can often dictate the flow of the entire battle. Some people will opt for
pokemon that can debuff the oponents team, but lets be honest overwhelming power is the way to go. Our opponent needs to 
be utterly humiliated for full immersion; Ash Ketchum never used a status debuff (to my knowledge) so neither will I. What I
want is an opener that can hit hard and fast. To compare

```{r Normies vs legendaries}
ggplot(pokemon, aes(x = Speed, y = Attack, color = Legendary)) +
  geom_point() +
  geom_smooth(method = "glm") +
  theme_cowplot()

ggplot(pokemon, aes(x = Speed, y = Sp..Atk, color = Legendary)) +
  geom_point() +
  geom_smooth(method = "glm") +
  theme_cowplot()
```

The scatterplot with glm overlay shows legendary pokemon are not only some of the fastest pokemon, they also appear to be some 
of the strongest in terms of attack/special attack power.

That being said legendary pokemon aren't exactly the easiest to come by. It might be more useful to look at the same
relationship while excluding legendary pokemon. In this scenario we might distinguish pokemon by their primary type. Since
there are a lot of types we should seperate into two or three subsets.
```{r Evaluate by type}
bug_to_fighting <- c("Bug", "Dark", "Dragon", "Electric", "Fairy", "Fighting") 
fighting_to_ground <- c("Fire", "Ghost", "Grass", "Ground", "Ice", "Normal")
posion_to_water <- c("Poison", "Psychic", "Rock", "Steel", "Water")

non_legendary <- dplyr::filter(pokemon, Legendary == "False") # Filter out legendary pokemon
# Create subset df's
Bug_Grass <- subset(non_legendary, Type.1 %in% bug_to_grass)
Fight_Ground <- subset(non_legendary, Type.1 %in% fighting_to_ground)
Posion_Water <- subset(non_legendary, Type.1 %in% posion_to_water)

```

```{r Evaluate speed vs Atk/Special Attack}

ggplot(Bug_Grass, aes(x = Speed, y = Sp..Atk, color = Type.1)) +
  geom_point() +
  geom_smooth(method = "glm") +
  ggtitle("Special Attack") +
  theme_cowplot()
ggplot(Bug_Grass, aes(x = Speed, y = Attack, color = Type.1)) +
  geom_point() +
  geom_smooth(method = "glm") +
  ggtitle("Attack") +
  theme_cowplot()

ggplot(Fight_Ground, aes(x = Speed, y = Sp..Atk, color = Type.1)) +
  geom_point() +
  geom_smooth(method = "glm") +
  ggtitle("Special Attack") +
  theme_cowplot()
ggplot(Fight_Ground, aes(x = Speed, y = Attack, color = Type.1)) +
  geom_point() +
  geom_smooth(method = "glm") +
  ggtitle("Attack") +
  theme_cowplot()

ggplot(Posion_Water, aes(x = Speed, y = Sp..Atk, color = Type.1)) +
  geom_point() +
  geom_smooth(method = "glm") +
  ggtitle("Special Attack") +
  theme_cowplot()
ggplot(Posion_Water, aes(x = Speed, y = Attack, color = Type.1)) +
  geom_point() +
  geom_smooth(method = "glm") +
  ggtitle("Attack") +
  theme_cowplot()
```
When we break it down this way we can get a general sense for what pokemon type has the highest performers are with regard to
my needs for an opener. We'll pick a few of the best looking types and compare those together

```{r}
best1 <- c("Psychic", "Ghost", "Dragon", "Grass")
high_performers <- subset(non_legendary, Type.1 %in% best1)

ggplot(high_performers, aes(x = Speed, y = Sp..Atk, color = Type.1)) +
  geom_point() +
  geom_smooth(method = "glm") +
  ggtitle("Special Attack") +
  theme_cowplot()
ggplot(high_performers, aes(x = Speed, y = Attack, color = Type.1)) +
  geom_point() +
  geom_smooth(method = "glm") +
  ggtitle("Attack") +
  theme_cowplot()
ggplot(high_performers, aes(x = Attack, y = Sp..Atk, color = Type.1)) +
  geom_point() +
  geom_smooth(method = "glm") +
  ggtitle("Damage") +
  theme_cowplot()
```

Comparing stats is great and all but how can we be sure that they will tell the whole story. Obviously there are a lot of other
factors which can influence the outcome of a battle. Therefore, it would be very nice if we had some pokemon battle data... Oh
wait we do. The Weedle's cave challenge was originally intended as a machine learning project to predict the outcome of a 1v1
pokemon battle using a large dataset of random 1v1 pokemon battles. Unfortunately the algorithim determining the dataset's
winners was unable to take into account many factors such as pokemon moves, and trainer decisions; however since the simulation
can't use those factors it must rely purely on pokemon stats which is exactly what we've been looking at. Lets load in the data
and see what we have.



Using data from the Weedle's cave challenge we can estimate the winrate ratio of each pokemon.
```{r Integrate Weedle's cave challenge data}
# Load data
battle_data <- read.csv("combats.csv")
# Filter out later generation pokemon
battle_data <- dplyr::filter(battle_data, Winner < 493)
battle_data <- dplyr::filter(battle_data, First_pokemon < 493)
battle_data <- dplyr::filter(battle_data, Second_pokemon < 493)
# Initialize column variables in pokemon df
pokemon$Wins <- 0
pokemon$Battles <- 0

# Populate new column variables in pokemon df
for (i in 1:length(battle_data$Winner)){
  # Battles
  pmon_index1 <- match(battle_data$First_pokemon[i], pokemon$X.) # Find index of pokemon in pokemon df using pokedex no.
  pmon_index2 <- match(battle_data$Second_pokemon[i], pokemon$X.)
  pmon_index1 <- pmon_index1[1] # In some cases there are two pokedex entries for the same pokemon bc of "Mega Evolutions" idk its too new for me lol. Anyways this makes sure we only get the index of the original pokemon form.
  pmon_index2 <- pmon_index2[1]
  pokemon[pmon_index1, 15] <- pokemon[pmon_index1, 15] + 1 # Add to relevant count
  pokemon[pmon_index2, 15] <- pokemon[pmon_index2, 15] + 1
  # Wins
  pmon_index3 <- match(battle_data$Winner[i], pokemon$X.)
  pmon_index3 <- pmon_index1[1]
  pokemon[pmon_index3, 14] <- pokemon[pmon_index3, 14] + 1}

pokemon <- dplyr::filter(pokemon, Battles != 0) # Filter out those random "Mega Evolutions"

# Handles win rate calculations
pokemon$WR <- 0
for (i in 1:length(pokemon$WR)){
  pokemon$WR[i] = pokemon$Wins[i]/pokemon$Battles[i]
  }
```

We now have simulated winrate data from the Weedle's cave challenge associated with our original pokemon dataset. So what 
happens if we check our "high performers" with the winrate data.
```{r WR data vs stats of "high performers"}
non_legendary <- dplyr::filter(pokemon, Legendary == "False")
best1 <- c("Psychic", "Ghost", "Dragon", "Grass")
high_performers <- subset(non_legendary, Type.1 %in% best1)

ggplot(high_performers, aes(x = Attack, y = (WR), color = Type.1)) +
  geom_point() +
  geom_smooth(method = "glm") +
  theme_cowplot()

ggplot(high_performers, aes(x = Sp..Atk, y = (WR), color = Type.1)) +
  geom_point() +
  geom_smooth(method = "glm") +
  theme_cowplot()

ggplot(high_performers, aes(x = Speed, y = (WR), color = Type.1)) +
  geom_point() +
  geom_smooth(method = "glm") +
  theme_cowplot()
```

Interestingly it seems that only dragon type pokemon benefit from increases in either speed, attack, or special attack stats.
Looking closer, we see that the most pronounced benefit seems to come from a higher speed stat.


To be honest, I never really saw myself as a Psychic, Ghost, or Grass gym leader. I really liked Water, Fire, Dragon, and
Flying pokemon so lets run the same modeling with those choices instead.

```{r Investigate personal preferences}
choices <- c("Water", "Fire", "Dragon", "Flying")
my_choices <- subset(non_legendary, Type.1 %in% choices)

ggplot(my_choices, aes(x = Attack, y = (WR), color = Type.1)) +
  geom_point() +
  geom_smooth(method = "glm") +
  theme_cowplot()

ggplot(my_choices, aes(x = Sp..Atk, y = (WR), color = Type.1)) +
  geom_point() +
  geom_smooth(method = "glm") +
  theme_cowplot()

ggplot(my_choices, aes(x = Speed, y = (WR), color = Type.1)) +
  geom_point() +
  geom_smooth(method = "glm") +
  theme_cowplot()
```

So apparently, Flying isn't a primary type which is unfortunate... Anyways, based on the data we've seen before it seems like 
the pokemon type that fits my requirements of hitting hard and fast is either a fire or dragon type.


My hypothesis: Hitting hard and and fast is in my opinion the best way to beat down all those pesky challengers to my 
hypothetical pokemon gym.

```{r GLM}
dragon <- subset(pokemon, Type.1 == "Dragon")
attack_glm <- glm(WR ~ Attack, data = dragon)
sp_attack_glm <- glm(WR ~ Sp..Atk, data = dragon)
speed_glm <- glm(WR ~ Speed, data = dragon)
cat("Attack:", attack_glm$aic)
cat("\nSpecial Attack:", sp_attack_glm$aic)
cat("\nSpeed:", speed_glm$aic)
```
GLM for the specific attributes I've chosen are not hugely different from one another. Perhaps there is another which I had not
expected.

```{r full GLM}
dragon_fullglm = glm(WR ~ Attack + Sp..Atk + Defense + Sp..Def + Speed + HP, data = dragon)
summary(dragon_fullglm)

dragon_fullglm = glm(WR ~ Attack + Sp..Def + Speed + HP, data = dragon)
summary(dragon_fullglm)

#dragon_fullglm = glm(WR ~ Attack + Sp..Atk + Defense + Sp..Def + Speed + HP, data = dragon)
#summary(dragon_fullglm)

#dragon_fullglm = glm(WR ~ Attack + Sp..Atk + Defense + Sp..Def + Speed + HP, data = dragon)
#summary(dragon_fullglm)
```


## Objectives

For this assignment you will need to identify a dataset from a public data archive use it to conduct the following steps:
- [ ] Data Wrangling
- [ ] Data Exploration
- [ ] Data Visualization
- [ ] Hypothesis testing using a generalized linear model

Your first step is to identify the dataset that you want to use and confirm that it is suitable for this assignment.
1. Contains between 100 and 10,000 observations.
2. Has a quantitative outcome variable.
3. Measures 4 or more potential explanatory variables. At least one quantitative variable.

